// compilation instructions
// gcc -O3 -o parser parser.c

// to get assembly code, add -S flag
// gcc -O3 -S parser.c

// clang -S -fno-asynchronous-unwind-tables -fno-exceptions -fno-rtti -masm=intel -mno-red-zone -O3 -m64 -mavx -mavx2 -msse4.1 -Wall -Wextra -mstackrealign -mllvm -inline-threshold=1000
// c2goasm -a -c -s -f parser.s parser_amd64.s

#include <stdio.h>

// empty string
#define NONE ""

// internal variables
#define BUFFER_SIZE 1024

// success code
#define SUCCESS 0

// error codes
#define INVALID_JSON_LEN 1
#define INVALID_KEY_LEN 2
#define INVALID_JSON_DATA_RECEIVED 3

// this method will extract content from array given
// start, end and steps positions
int parts(char* src, char* dst, int start, int end, int steps){
     int i, j;
     // for (i = start , j = 0 ; i <= end ; i += steps , ++j)
     for (i = start , j = 0 ; i < end ; i += steps , ++j)
           dst[j] = src[i];
     //for (i = 0 ; i < (end - start)/steps + 1 ; ++i)
     //      dst[i] = temp[i];
    return (end - start)/steps + 1;
}

// iterates over a json string looking for specified key
// @returns status code. any value != 0 means error
int lookup(char json[], char key[], int jsonLen, int keyLen, char *result) {
    // minimum valid json document is -> {}, []
    if (jsonLen < 2) {
       result = NONE;
       return INVALID_JSON_LEN;
    }
    // minimum key is a single char
    if (keyLen < 1) {
       result = NONE;
       return INVALID_KEY_LEN;
    }
    // 1. Initial check! validate if json starts with [ or { and ends with ] or }
    int valid = (json[0] == '[' || json[0] == '{') && (json[jsonLen-1] == ']' || json[jsonLen-1] == '}');
    if(!valid){
        result = NONE;
        return INVALID_JSON_DATA_RECEIVED;
    }
    // allocate our buffer
    char dst[BUFFER_SIZE];

    // start processing input json
    for (int i = 0; i < jsonLen; ++i){

    }
    // extract parts
    int slice = parts(json, dst, 0, jsonLen, 5);
    return SUCCESS;
}